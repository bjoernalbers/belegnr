#!/bin/sh
# belegnr â€” Generate sequential, unique document numbers (Belegnummern)

export PATH="/bin:/sbin:/usr/bin:/usr/sbin"

# File name of this script (without path).
SCRIPT_NAME="${0##*/}"

# Each document number starts with this string.
PREFIX="BE-"

# The first number.
START=1

# File to store the current number, which is overwritable via environment
# variable BELEGNR_FILE.
BELEGNR_FILE="${BELEGNR_FILE:-${HOME}/.belegnr}"

# Display usage information.
display_usage() {
cat <<EOF
Usage: ${SCRIPT_NAME} [OPTIONS]

Options:
  -c  Create new document number (Belegnummer)
  -h  Display this help and exit
  -r  Reset counter to given value, i.e. -r 1000
EOF
}

# Abort script with an error message.
abort() {
	echo "${SCRIPT_NAME}: $*" >&2
	exit 1
}

# Ask for confirmation.
confirm() {
	printf "%s (y/N): " "$1"
	read -r answer
	case "${answer}" in
		[yY]*)
			return 0
			;;
		*)
			return 1
			;;
	esac
}

# Reset counter.
reset_counter() {
	nr="$1"
	# If file exists, ask for confirmation before reset.
	if [ -f "${BELEGNR_FILE}" ]; then
		confirm "Really reset counter?" || return
	fi
	write_nr "${nr}" && print_nr "${nr}"
}

# Create new document number.
create_nr() {
	# If file exists, read and increment number.
	if [ -f "${BELEGNR_FILE}" ]; then
		nr=$(read_nr)
		nr=$((nr+1))
	# Else start from scratch.
	else
		nr="${START}"
	fi
	write_nr "${nr}" && print_nr "${nr}"
}

# Read and validate current number from file.
read_nr() {
	nr=$(cat "${BELEGNR_FILE}") || abort "could not read file: ${BELEGNR_FILE}"
	[ "${nr}" -ge 0 ] 2> /dev/null || abort "file contains no valid number: ${BELEGNR_FILE}"
	echo "${nr}"
}

# Write current number to file.
write_nr() {
	nr="$1"
	tmp=$(mktemp) || abort "failed to create temporary file"
	if ! (echo "${nr}" > "${tmp}" && mv -f "${tmp}" "${BELEGNR_FILE}"); then
	       abort "could not write file: ${BELEGNR_FILE}"
	fi
}

# Print the formatted document number.
print_nr() {
	nr="$1"
	echo "${PREFIX}${nr}"
}

# Abort, if $HOME is not set.
[ -n "${HOME}" ] || abort "variable HOME not defined or empty"

# Parse options.
while getopts 'chr:' opt; do
	case "${opt}" in
		c)
			create_nr
			exit 0
			;;
		h)
			display_usage
			exit 0
			;;
		r)
			reset_counter "${OPTARG}"
			exit 0
			;;
		*)
			display_usage
			exit 1
			;;
	esac
done

# Display usage if no option was selected.
display_usage
